/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * YAPP26 WEB2
 * SSOK ÏÑúÎπÑÏä§ API Î™ÖÏÑ∏
 * OpenAPI spec version: v1
 */

import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { useQuery, useSuspenseQuery } from "@tanstack/react-query";
import { http } from "./api/http";
import type {
  GetAccommodationByTableIdAndUserIdParams,
  GetAccommodationCountByTableIdParams,
  StandardResponseAccommodationCountResponse,
  StandardResponseAccommodationPageResponse,
  StandardResponseString,
  StandardResponseUserResponse,
} from "./index.schemas";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * KAKAO ÏÜåÏÖú Î°úÍ∑∏Ïù∏ ÏöîÏ≤≠ URI
 * @summary KAKAO
 */
export type kakaoLoginRedirectResponse302 = {
  data: undefined;
  status: 302;
};

export type kakaoLoginRedirectResponseComposite = kakaoLoginRedirectResponse302;

export type kakaoLoginRedirectResponse = kakaoLoginRedirectResponseComposite & {
  headers: Headers;
};

export const getKakaoLoginRedirectUrl = () => {
  return `https://api.ssok.info/api/oauth/kakao`;
};

export const kakaoLoginRedirect = async (
  options?: RequestInit,
): Promise<kakaoLoginRedirectResponse> => {
  return http<kakaoLoginRedirectResponse>(getKakaoLoginRedirectUrl(), {
    ...options,
    method: "GET",
  });
};

export const getKakaoLoginRedirectQueryKey = () => {
  return [`https://api.ssok.info/api/oauth/kakao`] as const;
};

export const getKakaoLoginRedirectQueryOptions = <
  TData = Awaited<ReturnType<typeof kakaoLoginRedirect>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof kakaoLoginRedirect>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof http>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getKakaoLoginRedirectQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof kakaoLoginRedirect>>
  > = ({ signal }) => kakaoLoginRedirect({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof kakaoLoginRedirect>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KakaoLoginRedirectQueryResult = NonNullable<
  Awaited<ReturnType<typeof kakaoLoginRedirect>>
>;
export type KakaoLoginRedirectQueryError = undefined;

export function useKakaoLoginRedirect<
  TData = Awaited<ReturnType<typeof kakaoLoginRedirect>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof kakaoLoginRedirect>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof kakaoLoginRedirect>>,
          TError,
          Awaited<ReturnType<typeof kakaoLoginRedirect>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKakaoLoginRedirect<
  TData = Awaited<ReturnType<typeof kakaoLoginRedirect>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof kakaoLoginRedirect>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof kakaoLoginRedirect>>,
          TError,
          Awaited<ReturnType<typeof kakaoLoginRedirect>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKakaoLoginRedirect<
  TData = Awaited<ReturnType<typeof kakaoLoginRedirect>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof kakaoLoginRedirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary KAKAO
 */

export function useKakaoLoginRedirect<
  TData = Awaited<ReturnType<typeof kakaoLoginRedirect>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof kakaoLoginRedirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getKakaoLoginRedirectQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary KAKAO
 */
export const prefetchKakaoLoginRedirectQuery = async <
  TData = Awaited<ReturnType<typeof kakaoLoginRedirect>>,
  TError = void,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof kakaoLoginRedirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
): Promise<QueryClient> => {
  const queryOptions = getKakaoLoginRedirectQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getKakaoLoginRedirectSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof kakaoLoginRedirect>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof kakaoLoginRedirect>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof http>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getKakaoLoginRedirectQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof kakaoLoginRedirect>>
  > = ({ signal }) => kakaoLoginRedirect({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof kakaoLoginRedirect>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KakaoLoginRedirectSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof kakaoLoginRedirect>>
>;
export type KakaoLoginRedirectSuspenseQueryError = undefined;

export function useKakaoLoginRedirectSuspense<
  TData = Awaited<ReturnType<typeof kakaoLoginRedirect>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof kakaoLoginRedirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKakaoLoginRedirectSuspense<
  TData = Awaited<ReturnType<typeof kakaoLoginRedirect>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof kakaoLoginRedirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKakaoLoginRedirectSuspense<
  TData = Awaited<ReturnType<typeof kakaoLoginRedirect>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof kakaoLoginRedirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary KAKAO
 */

export function useKakaoLoginRedirectSuspense<
  TData = Awaited<ReturnType<typeof kakaoLoginRedirect>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof kakaoLoginRedirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getKakaoLoginRedirectSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type getUserResponse200 = {
  data: StandardResponseUserResponse;
  status: 200;
};

export type getUserResponseComposite = getUserResponse200;

export type getUserResponse = getUserResponseComposite & {
  headers: Headers;
};

export const getGetUserUrl = (id: number) => {
  return `https://api.ssok.info/api/mock/user/${id}`;
};

export const getUser = async (
  id: number,
  options?: RequestInit,
): Promise<getUserResponse> => {
  return http<getUserResponse>(getGetUserUrl(id), {
    ...options,
    method: "GET",
  });
};

export const getGetUserQueryKey = (id: number) => {
  return [`https://api.ssok.info/api/mock/user/${id}`] as const;
};

export const getGetUserQueryOptions = <
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    >;
    request?: SecondParameter<typeof http>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({
    signal,
  }) => getUser(id, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUser>>
>;
export type GetUserQueryError = unknown;

export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = unknown,
>(
  id: number,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          Awaited<ReturnType<typeof getUser>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          Awaited<ReturnType<typeof getUser>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUserQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchGetUserQuery = async <
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  id: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    >;
    request?: SecondParameter<typeof http>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetUserQueryOptions(id, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getGetUserSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUser>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({
    signal,
  }) => getUser(id, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUserSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUser>>
>;
export type GetUserSuspenseQueryError = unknown;

export function useGetUserSuspense<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = unknown,
>(
  id: number,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUser>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserSuspense<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUser>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserSuspense<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUser>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetUserSuspense<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUser>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUserSuspenseQueryOptions(id, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type successResponse200 = {
  data: StandardResponseString;
  status: 200;
};

export type successResponseComposite = successResponse200;

export type successResponse = successResponseComposite & {
  headers: Headers;
};

export const getSuccessUrl = () => {
  return `https://api.ssok.info/api/mock/success`;
};

export const success = async (
  options?: RequestInit,
): Promise<successResponse> => {
  return http<successResponse>(getSuccessUrl(), {
    ...options,
    method: "GET",
  });
};

export const getSuccessQueryKey = () => {
  return [`https://api.ssok.info/api/mock/success`] as const;
};

export const getSuccessQueryOptions = <
  TData = Awaited<ReturnType<typeof success>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof success>>, TError, TData>
  >;
  request?: SecondParameter<typeof http>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSuccessQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof success>>> = ({
    signal,
  }) => success({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof success>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SuccessQueryResult = NonNullable<
  Awaited<ReturnType<typeof success>>
>;
export type SuccessQueryError = unknown;

export function useSuccess<
  TData = Awaited<ReturnType<typeof success>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof success>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof success>>,
          TError,
          Awaited<ReturnType<typeof success>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSuccess<
  TData = Awaited<ReturnType<typeof success>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof success>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof success>>,
          TError,
          Awaited<ReturnType<typeof success>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSuccess<
  TData = Awaited<ReturnType<typeof success>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof success>>, TError, TData>
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useSuccess<
  TData = Awaited<ReturnType<typeof success>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof success>>, TError, TData>
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSuccessQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchSuccessQuery = async <
  TData = Awaited<ReturnType<typeof success>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof success>>, TError, TData>
    >;
    request?: SecondParameter<typeof http>;
  },
): Promise<QueryClient> => {
  const queryOptions = getSuccessQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getSuccessSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof success>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<Awaited<ReturnType<typeof success>>, TError, TData>
  >;
  request?: SecondParameter<typeof http>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSuccessQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof success>>> = ({
    signal,
  }) => success({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof success>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SuccessSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof success>>
>;
export type SuccessSuspenseQueryError = unknown;

export function useSuccessSuspense<
  TData = Awaited<ReturnType<typeof success>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof success>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSuccessSuspense<
  TData = Awaited<ReturnType<typeof success>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof success>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSuccessSuspense<
  TData = Awaited<ReturnType<typeof success>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof success>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useSuccessSuspense<
  TData = Awaited<ReturnType<typeof success>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof success>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSuccessSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type exceptionErrorResponse200 = {
  data: StandardResponseString;
  status: 200;
};

export type exceptionErrorResponseComposite = exceptionErrorResponse200;

export type exceptionErrorResponse = exceptionErrorResponseComposite & {
  headers: Headers;
};

export const getExceptionErrorUrl = () => {
  return `https://api.ssok.info/api/mock/exception-error`;
};

export const exceptionError = async (
  options?: RequestInit,
): Promise<exceptionErrorResponse> => {
  return http<exceptionErrorResponse>(getExceptionErrorUrl(), {
    ...options,
    method: "GET",
  });
};

export const getExceptionErrorQueryKey = () => {
  return [`https://api.ssok.info/api/mock/exception-error`] as const;
};

export const getExceptionErrorQueryOptions = <
  TData = Awaited<ReturnType<typeof exceptionError>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof exceptionError>>, TError, TData>
  >;
  request?: SecondParameter<typeof http>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getExceptionErrorQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof exceptionError>>> = ({
    signal,
  }) => exceptionError({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof exceptionError>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ExceptionErrorQueryResult = NonNullable<
  Awaited<ReturnType<typeof exceptionError>>
>;
export type ExceptionErrorQueryError = unknown;

export function useExceptionError<
  TData = Awaited<ReturnType<typeof exceptionError>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof exceptionError>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof exceptionError>>,
          TError,
          Awaited<ReturnType<typeof exceptionError>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useExceptionError<
  TData = Awaited<ReturnType<typeof exceptionError>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof exceptionError>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof exceptionError>>,
          TError,
          Awaited<ReturnType<typeof exceptionError>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useExceptionError<
  TData = Awaited<ReturnType<typeof exceptionError>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof exceptionError>>, TError, TData>
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useExceptionError<
  TData = Awaited<ReturnType<typeof exceptionError>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof exceptionError>>, TError, TData>
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getExceptionErrorQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchExceptionErrorQuery = async <
  TData = Awaited<ReturnType<typeof exceptionError>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof exceptionError>>, TError, TData>
    >;
    request?: SecondParameter<typeof http>;
  },
): Promise<QueryClient> => {
  const queryOptions = getExceptionErrorQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getExceptionErrorSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof exceptionError>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof exceptionError>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof http>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getExceptionErrorQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof exceptionError>>> = ({
    signal,
  }) => exceptionError({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof exceptionError>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ExceptionErrorSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof exceptionError>>
>;
export type ExceptionErrorSuspenseQueryError = unknown;

export function useExceptionErrorSuspense<
  TData = Awaited<ReturnType<typeof exceptionError>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof exceptionError>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useExceptionErrorSuspense<
  TData = Awaited<ReturnType<typeof exceptionError>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof exceptionError>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useExceptionErrorSuspense<
  TData = Awaited<ReturnType<typeof exceptionError>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof exceptionError>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useExceptionErrorSuspense<
  TData = Awaited<ReturnType<typeof exceptionError>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof exceptionError>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getExceptionErrorSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type customErrorResponse200 = {
  data: StandardResponseString;
  status: 200;
};

export type customErrorResponseComposite = customErrorResponse200;

export type customErrorResponse = customErrorResponseComposite & {
  headers: Headers;
};

export const getCustomErrorUrl = () => {
  return `https://api.ssok.info/api/mock/custom-error`;
};

export const customError = async (
  options?: RequestInit,
): Promise<customErrorResponse> => {
  return http<customErrorResponse>(getCustomErrorUrl(), {
    ...options,
    method: "GET",
  });
};

export const getCustomErrorQueryKey = () => {
  return [`https://api.ssok.info/api/mock/custom-error`] as const;
};

export const getCustomErrorQueryOptions = <
  TData = Awaited<ReturnType<typeof customError>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof customError>>, TError, TData>
  >;
  request?: SecondParameter<typeof http>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCustomErrorQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof customError>>> = ({
    signal,
  }) => customError({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof customError>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CustomErrorQueryResult = NonNullable<
  Awaited<ReturnType<typeof customError>>
>;
export type CustomErrorQueryError = unknown;

export function useCustomError<
  TData = Awaited<ReturnType<typeof customError>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof customError>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customError>>,
          TError,
          Awaited<ReturnType<typeof customError>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCustomError<
  TData = Awaited<ReturnType<typeof customError>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof customError>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customError>>,
          TError,
          Awaited<ReturnType<typeof customError>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCustomError<
  TData = Awaited<ReturnType<typeof customError>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof customError>>, TError, TData>
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useCustomError<
  TData = Awaited<ReturnType<typeof customError>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof customError>>, TError, TData>
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCustomErrorQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchCustomErrorQuery = async <
  TData = Awaited<ReturnType<typeof customError>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof customError>>, TError, TData>
    >;
    request?: SecondParameter<typeof http>;
  },
): Promise<QueryClient> => {
  const queryOptions = getCustomErrorQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getCustomErrorSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof customError>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof customError>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof http>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCustomErrorQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof customError>>> = ({
    signal,
  }) => customError({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof customError>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CustomErrorSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof customError>>
>;
export type CustomErrorSuspenseQueryError = unknown;

export function useCustomErrorSuspense<
  TData = Awaited<ReturnType<typeof customError>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof customError>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCustomErrorSuspense<
  TData = Awaited<ReturnType<typeof customError>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof customError>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCustomErrorSuspense<
  TData = Awaited<ReturnType<typeof customError>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof customError>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useCustomErrorSuspense<
  TData = Awaited<ReturnType<typeof customError>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof customError>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCustomErrorSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ...
 * @summary Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
 */
export type healthCheckResponse200 = {
  data: string;
  status: 200;
};

export type healthCheckResponseComposite = healthCheckResponse200;

export type healthCheckResponse = healthCheckResponseComposite & {
  headers: Headers;
};

export const getHealthCheckUrl = () => {
  return `https://api.ssok.info/api/health`;
};

export const healthCheck = async (
  options?: RequestInit,
): Promise<healthCheckResponse> => {
  return http<healthCheckResponse>(getHealthCheckUrl(), {
    ...options,
    method: "GET",
  });
};

export const getHealthCheckQueryKey = () => {
  return [`https://api.ssok.info/api/health`] as const;
};

export const getHealthCheckQueryOptions = <
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
  >;
  request?: SecondParameter<typeof http>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthCheckQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheck>>> = ({
    signal,
  }) => healthCheck({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof healthCheck>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthCheckQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthCheck>>
>;
export type HealthCheckQueryError = unknown;

export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
 */

export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHealthCheckQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
 */
export const prefetchHealthCheckQuery = async <
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
    >;
    request?: SecondParameter<typeof http>;
  },
): Promise<QueryClient> => {
  const queryOptions = getHealthCheckQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getHealthCheckSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof healthCheck>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof http>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthCheckQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheck>>> = ({
    signal,
  }) => healthCheck({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof healthCheck>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthCheckSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthCheck>>
>;
export type HealthCheckSuspenseQueryError = unknown;

export function useHealthCheckSuspense<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof healthCheck>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthCheckSuspense<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof healthCheck>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthCheckSuspense<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof healthCheck>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
 */

export function useHealthCheckSuspense<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof healthCheck>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHealthCheckSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏàôÏÜå Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏàôÏÜå Î™©Î°ù Ï°∞Ìöå
 */
export type getAccommodationByTableIdAndUserIdResponse200 = {
  data: StandardResponseAccommodationPageResponse;
  status: 200;
};

export type getAccommodationByTableIdAndUserIdResponseComposite =
  getAccommodationByTableIdAndUserIdResponse200;

export type getAccommodationByTableIdAndUserIdResponse =
  getAccommodationByTableIdAndUserIdResponseComposite & {
    headers: Headers;
  };

export const getGetAccommodationByTableIdAndUserIdUrl = (
  params: GetAccommodationByTableIdAndUserIdParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://api.ssok.info/api/accommodations/search?${stringifiedParams}`
    : `https://api.ssok.info/api/accommodations/search`;
};

export const getAccommodationByTableIdAndUserId = async (
  params: GetAccommodationByTableIdAndUserIdParams,
  options?: RequestInit,
): Promise<getAccommodationByTableIdAndUserIdResponse> => {
  return http<getAccommodationByTableIdAndUserIdResponse>(
    getGetAccommodationByTableIdAndUserIdUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetAccommodationByTableIdAndUserIdQueryKey = (
  params: GetAccommodationByTableIdAndUserIdParams,
) => {
  return [
    `https://api.ssok.info/api/accommodations/search`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetAccommodationByTableIdAndUserIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
  TError = unknown,
>(
  params: GetAccommodationByTableIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetAccommodationByTableIdAndUserIdQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>
  > = ({ signal }) =>
    getAccommodationByTableIdAndUserId(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAccommodationByTableIdAndUserIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>
>;
export type GetAccommodationByTableIdAndUserIdQueryError = unknown;

export function useGetAccommodationByTableIdAndUserId<
  TData = Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
  TError = unknown,
>(
  params: GetAccommodationByTableIdAndUserIdParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
          TError,
          Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAccommodationByTableIdAndUserId<
  TData = Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
  TError = unknown,
>(
  params: GetAccommodationByTableIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
          TError,
          Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAccommodationByTableIdAndUserId<
  TData = Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
  TError = unknown,
>(
  params: GetAccommodationByTableIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÏàôÏÜå Î™©Î°ù Ï°∞Ìöå
 */

export function useGetAccommodationByTableIdAndUserId<
  TData = Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
  TError = unknown,
>(
  params: GetAccommodationByTableIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAccommodationByTableIdAndUserIdQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ÏàôÏÜå Î™©Î°ù Ï°∞Ìöå
 */
export const prefetchGetAccommodationByTableIdAndUserIdQuery = async <
  TData = Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  params: GetAccommodationByTableIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetAccommodationByTableIdAndUserIdQueryOptions(
    params,
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getGetAccommodationByTableIdAndUserIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
  TError = unknown,
>(
  params: GetAccommodationByTableIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetAccommodationByTableIdAndUserIdQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>
  > = ({ signal }) =>
    getAccommodationByTableIdAndUserId(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAccommodationByTableIdAndUserIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>
>;
export type GetAccommodationByTableIdAndUserIdSuspenseQueryError = unknown;

export function useGetAccommodationByTableIdAndUserIdSuspense<
  TData = Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
  TError = unknown,
>(
  params: GetAccommodationByTableIdAndUserIdParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAccommodationByTableIdAndUserIdSuspense<
  TData = Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
  TError = unknown,
>(
  params: GetAccommodationByTableIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAccommodationByTableIdAndUserIdSuspense<
  TData = Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
  TError = unknown,
>(
  params: GetAccommodationByTableIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÏàôÏÜå Î™©Î°ù Ï°∞Ìöå
 */

export function useGetAccommodationByTableIdAndUserIdSuspense<
  TData = Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
  TError = unknown,
>(
  params: GetAccommodationByTableIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByTableIdAndUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetAccommodationByTableIdAndUserIdSuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌÖåÏù¥Î∏îÏóê Ìè¨Ìï®Îêú ÏàôÏÜåÏùò Í∞úÏàòÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÌÖåÏù¥Î∏î ÏàôÏÜå Í∞úÏàò Ï°∞Ìöå
 */
export type getAccommodationCountByTableIdResponse200 = {
  data: StandardResponseAccommodationCountResponse;
  status: 200;
};

export type getAccommodationCountByTableIdResponseComposite =
  getAccommodationCountByTableIdResponse200;

export type getAccommodationCountByTableIdResponse =
  getAccommodationCountByTableIdResponseComposite & {
    headers: Headers;
  };

export const getGetAccommodationCountByTableIdUrl = (
  params: GetAccommodationCountByTableIdParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://api.ssok.info/api/accommodations/count?${stringifiedParams}`
    : `https://api.ssok.info/api/accommodations/count`;
};

export const getAccommodationCountByTableId = async (
  params: GetAccommodationCountByTableIdParams,
  options?: RequestInit,
): Promise<getAccommodationCountByTableIdResponse> => {
  return http<getAccommodationCountByTableIdResponse>(
    getGetAccommodationCountByTableIdUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetAccommodationCountByTableIdQueryKey = (
  params: GetAccommodationCountByTableIdParams,
) => {
  return [
    `https://api.ssok.info/api/accommodations/count`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetAccommodationCountByTableIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
  TError = unknown,
>(
  params: GetAccommodationCountByTableIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAccommodationCountByTableIdQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAccommodationCountByTableId>>
  > = ({ signal }) =>
    getAccommodationCountByTableId(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAccommodationCountByTableIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccommodationCountByTableId>>
>;
export type GetAccommodationCountByTableIdQueryError = unknown;

export function useGetAccommodationCountByTableId<
  TData = Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
  TError = unknown,
>(
  params: GetAccommodationCountByTableIdParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
          TError,
          Awaited<ReturnType<typeof getAccommodationCountByTableId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAccommodationCountByTableId<
  TData = Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
  TError = unknown,
>(
  params: GetAccommodationCountByTableIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
          TError,
          Awaited<ReturnType<typeof getAccommodationCountByTableId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAccommodationCountByTableId<
  TData = Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
  TError = unknown,
>(
  params: GetAccommodationCountByTableIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÌÖåÏù¥Î∏î ÏàôÏÜå Í∞úÏàò Ï°∞Ìöå
 */

export function useGetAccommodationCountByTableId<
  TData = Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
  TError = unknown,
>(
  params: GetAccommodationCountByTableIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAccommodationCountByTableIdQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ÌÖåÏù¥Î∏î ÏàôÏÜå Í∞úÏàò Ï°∞Ìöå
 */
export const prefetchGetAccommodationCountByTableIdQuery = async <
  TData = Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  params: GetAccommodationCountByTableIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetAccommodationCountByTableIdQueryOptions(
    params,
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getGetAccommodationCountByTableIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
  TError = unknown,
>(
  params: GetAccommodationCountByTableIdParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAccommodationCountByTableIdQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAccommodationCountByTableId>>
  > = ({ signal }) =>
    getAccommodationCountByTableId(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAccommodationCountByTableIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccommodationCountByTableId>>
>;
export type GetAccommodationCountByTableIdSuspenseQueryError = unknown;

export function useGetAccommodationCountByTableIdSuspense<
  TData = Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
  TError = unknown,
>(
  params: GetAccommodationCountByTableIdParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAccommodationCountByTableIdSuspense<
  TData = Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
  TError = unknown,
>(
  params: GetAccommodationCountByTableIdParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAccommodationCountByTableIdSuspense<
  TData = Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
  TError = unknown,
>(
  params: GetAccommodationCountByTableIdParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÌÖåÏù¥Î∏î ÏàôÏÜå Í∞úÏàò Ï°∞Ìöå
 */

export function useGetAccommodationCountByTableIdSuspense<
  TData = Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
  TError = unknown,
>(
  params: GetAccommodationCountByTableIdParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationCountByTableId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAccommodationCountByTableIdSuspenseQueryOptions(
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
