/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * YAPP26 WEB2
 * SSOK ÏÑúÎπÑÏä§ API Î™ÖÏÑ∏
 * OpenAPI spec version: v1
 */

import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import { http } from "./api/http";
import type {
  AccommodationRegisterRequest,
  AddAccommodationRequest,
  CreateComparisonTableRequest,
  ExchangeKakaoTokenParams,
  GetAccommodationByBoardIdAndUserIdParams,
  GetAccommodationCountByBoardIdParams,
  GetKakaoAuthorizeUrlParams,
  GetTripBoardsParams,
  StandardResponseAccommodationCountResponse,
  StandardResponseAccommodationPageResponse,
  StandardResponseAccommodationRegisterResponse,
  StandardResponseAccommodationResponse,
  StandardResponseAmenityFactorList,
  StandardResponseAuthorizeUrlResponse,
  StandardResponseBoolean,
  StandardResponseComparisonFactorList,
  StandardResponseComparisonTableResponse,
  StandardResponseCreateComparisonTableResponse,
  StandardResponseLogoutResponse,
  StandardResponseOauthLoginResponse,
  StandardResponseTripBoardCreateResponse,
  StandardResponseTripBoardDeleteResponse,
  StandardResponseTripBoardLeaveResponse,
  StandardResponseTripBoardPageResponse,
  StandardResponseTripBoardUpdateResponse,
  TripBoardCreateRequest,
  TripBoardLeaveRequest,
  TripBoardUpdateRequest,
  UpdateComparisonTableRequest,
} from "./index.schemas";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Í∏∞Ï°¥ Ïó¨Ìñâ Î≥¥ÎìúÏùò Í∏∞Î≥∏ Ï†ïÎ≥¥(Î≥¥Îìú Ïù¥Î¶Ñ, Î™©Ï†ÅÏßÄ, Ïó¨Ìñâ Í∏∞Í∞Ñ)Î•º ÏàòÏ†ïÌï©ÎãàÎã§. JWT Ïù∏Ï¶ùÏùÑ ÌÜµÌï¥ ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Î•º Ï∂îÏ∂úÌïòÍ≥†, ÏàòÏ†ïÎêú Î≥¥Îìú Ï†ïÎ≥¥Î•º Î∞òÌôòÌï©ÎãàÎã§.
 * @summary Ïó¨Ìñâ Î≥¥Îìú ÏàòÏ†ï
 */
export type updateTripBoardResponse200 = {
  data: StandardResponseTripBoardUpdateResponse;
  status: 200;
};

export type updateTripBoardResponseComposite = updateTripBoardResponse200;

export type updateTripBoardResponse = updateTripBoardResponseComposite & {
  headers: Headers;
};

export const getUpdateTripBoardUrl = (boardId: number) => {
  return `https://api.ssok.info/api/trip-boards/${boardId}`;
};

export const updateTripBoard = async (
  boardId: number,
  tripBoardUpdateRequest: TripBoardUpdateRequest,
  options?: RequestInit,
): Promise<updateTripBoardResponse> => {
  return http<updateTripBoardResponse>(getUpdateTripBoardUrl(boardId), {
    ...options,
    method: "PUT",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(tripBoardUpdateRequest),
  });
};

export const getUpdateTripBoardMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTripBoard>>,
    TError,
    { boardId: number; data: TripBoardUpdateRequest },
    TContext
  >;
  request?: SecondParameter<typeof http>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTripBoard>>,
  TError,
  { boardId: number; data: TripBoardUpdateRequest },
  TContext
> => {
  const mutationKey = ["updateTripBoard"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTripBoard>>,
    { boardId: number; data: TripBoardUpdateRequest }
  > = (props) => {
    const { boardId, data } = props ?? {};

    return updateTripBoard(boardId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateTripBoardMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTripBoard>>
>;
export type UpdateTripBoardMutationBody = TripBoardUpdateRequest;
export type UpdateTripBoardMutationError = unknown;

/**
 * @summary Ïó¨Ìñâ Î≥¥Îìú ÏàòÏ†ï
 */
export const useUpdateTripBoard = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateTripBoard>>,
      TError,
      { boardId: number; data: TripBoardUpdateRequest },
      TContext
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateTripBoard>>,
  TError,
  { boardId: number; data: TripBoardUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateTripBoardMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Ïó¨Ìñâ Î≥¥ÎìúÏôÄ Í¥ÄÎ†®Îêú Î™®Îì† Îç∞Ïù¥ÌÑ∞Î•º ÏÇ≠Ï†úÌï©ÎãàÎã§. Ïò§ÏßÅ Ïó¨Ìñâ Î≥¥ÎìúÏùò ÏÜåÏú†Ïûê(OWNER)ÎßåÏù¥ ÏÇ≠Ï†úÌï† Ïàò ÏûàÏúºÎ©∞, ÏÇ≠Ï†ú Ïãú Ìï¥Îãπ Î≥¥ÎìúÏóê Ïó∞Í¥ÄÎêú Î™®Îì† Î¶¨ÏÜåÏä§(ÏàôÏÜå Ï†ïÎ≥¥, Î©§Î≤Ñ Îß§Ìïë Í¥ÄÍ≥Ñ, ÎπÑÍµêÌëú Îì±)Í∞Ä Ìï®Íªò Ï†úÍ±∞Îê©ÎãàÎã§.
 * @summary Ïó¨Ìñâ Î≥¥Îìú ÏÇ≠Ï†ú
 */
export type deleteTripBoardResponse200 = {
  data: StandardResponseTripBoardDeleteResponse;
  status: 200;
};

export type deleteTripBoardResponseComposite = deleteTripBoardResponse200;

export type deleteTripBoardResponse = deleteTripBoardResponseComposite & {
  headers: Headers;
};

export const getDeleteTripBoardUrl = (boardId: number) => {
  return `https://api.ssok.info/api/trip-boards/${boardId}`;
};

export const deleteTripBoard = async (
  boardId: number,
  options?: RequestInit,
): Promise<deleteTripBoardResponse> => {
  return http<deleteTripBoardResponse>(getDeleteTripBoardUrl(boardId), {
    ...options,
    method: "DELETE",
  });
};

export const getDeleteTripBoardMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteTripBoard>>,
    TError,
    { boardId: number },
    TContext
  >;
  request?: SecondParameter<typeof http>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteTripBoard>>,
  TError,
  { boardId: number },
  TContext
> => {
  const mutationKey = ["deleteTripBoard"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteTripBoard>>,
    { boardId: number }
  > = (props) => {
    const { boardId } = props ?? {};

    return deleteTripBoard(boardId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteTripBoardMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteTripBoard>>
>;

export type DeleteTripBoardMutationError = unknown;

/**
 * @summary Ïó¨Ìñâ Î≥¥Îìú ÏÇ≠Ï†ú
 */
export const useDeleteTripBoard = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteTripBoard>>,
      TError,
      { boardId: number },
      TContext
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteTripBoard>>,
  TError,
  { boardId: number },
  TContext
> => {
  const mutationOptions = getDeleteTripBoardMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÎπÑÍµêÌëú Î©îÌÉÄ Îç∞Ïù¥ÌÑ∞ÏôÄ Ìè¨Ìï®Îêú ÏàôÏÜå Ï†ïÎ≥¥ Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§. (Authorization Ìó§ÎçîÏóê Bearer ÌÜ†ÌÅ∞ ÌïÑÏöî)
 * @summary ÎπÑÍµêÌëú Ï°∞Ìöå
 */
export type getComparisonTableResponse200 = {
  data: StandardResponseComparisonTableResponse;
  status: 200;
};

export type getComparisonTableResponseComposite = getComparisonTableResponse200;

export type getComparisonTableResponse = getComparisonTableResponseComposite & {
  headers: Headers;
};

export const getGetComparisonTableUrl = (tableId: number) => {
  return `https://api.ssok.info/api/comparison/${tableId}`;
};

export const getComparisonTable = async (
  tableId: number,
  options?: RequestInit,
): Promise<getComparisonTableResponse> => {
  return http<getComparisonTableResponse>(getGetComparisonTableUrl(tableId), {
    ...options,
    method: "GET",
  });
};

export const getGetComparisonTableQueryKey = (tableId?: number) => {
  return [`https://api.ssok.info/api/comparison/${tableId}`] as const;
};

export const getGetComparisonTableQueryOptions = <
  TData = Awaited<ReturnType<typeof getComparisonTable>>,
  TError = unknown,
>(
  tableId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getComparisonTable>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetComparisonTableQueryKey(tableId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getComparisonTable>>
  > = ({ signal }) =>
    getComparisonTable(tableId, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!tableId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getComparisonTable>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetComparisonTableQueryResult = NonNullable<
  Awaited<ReturnType<typeof getComparisonTable>>
>;
export type GetComparisonTableQueryError = unknown;

export function useGetComparisonTable<
  TData = Awaited<ReturnType<typeof getComparisonTable>>,
  TError = unknown,
>(
  tableId: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getComparisonTable>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getComparisonTable>>,
          TError,
          Awaited<ReturnType<typeof getComparisonTable>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetComparisonTable<
  TData = Awaited<ReturnType<typeof getComparisonTable>>,
  TError = unknown,
>(
  tableId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getComparisonTable>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getComparisonTable>>,
          TError,
          Awaited<ReturnType<typeof getComparisonTable>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetComparisonTable<
  TData = Awaited<ReturnType<typeof getComparisonTable>>,
  TError = unknown,
>(
  tableId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getComparisonTable>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÎπÑÍµêÌëú Ï°∞Ìöå
 */

export function useGetComparisonTable<
  TData = Awaited<ReturnType<typeof getComparisonTable>>,
  TError = unknown,
>(
  tableId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getComparisonTable>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetComparisonTableQueryOptions(tableId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ÎπÑÍµêÌëú Ï°∞Ìöå
 */
export const prefetchGetComparisonTableQuery = async <
  TData = Awaited<ReturnType<typeof getComparisonTable>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  tableId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getComparisonTable>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetComparisonTableQueryOptions(tableId, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getGetComparisonTableSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getComparisonTable>>,
  TError = unknown,
>(
  tableId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getComparisonTable>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetComparisonTableQueryKey(tableId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getComparisonTable>>
  > = ({ signal }) =>
    getComparisonTable(tableId, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getComparisonTable>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetComparisonTableSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getComparisonTable>>
>;
export type GetComparisonTableSuspenseQueryError = unknown;

export function useGetComparisonTableSuspense<
  TData = Awaited<ReturnType<typeof getComparisonTable>>,
  TError = unknown,
>(
  tableId: number,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getComparisonTable>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetComparisonTableSuspense<
  TData = Awaited<ReturnType<typeof getComparisonTable>>,
  TError = unknown,
>(
  tableId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getComparisonTable>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetComparisonTableSuspense<
  TData = Awaited<ReturnType<typeof getComparisonTable>>,
  TError = unknown,
>(
  tableId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getComparisonTable>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
/**
 * @summary ÎπÑÍµêÌëú Ï°∞Ìöå
 */

export function useGetComparisonTableSuspense<
  TData = Awaited<ReturnType<typeof getComparisonTable>>,
  TError = unknown,
>(
  tableId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getComparisonTable>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
} {
  const queryOptions = getGetComparisonTableSuspenseQueryOptions(
    tableId,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÎπÑÍµêÌëú Î©îÌÉÄ Îç∞Ïù¥ÌÑ∞(Ï†úÎ™©)ÏôÄ ÏàôÏÜå ÏÑ∏Î∂Ä ÎÇ¥Ïö©, ÎπÑÍµê Í∏∞Ï§Ä Ï†ïÎ†¨ ÏàúÏÑú, ÏàôÏÜå Ï†ïÎ†¨ ÏàúÏÑúÎ•º ÏàòÏ†ïÌï©ÎãàÎã§. (Authorization Ìó§ÎçîÏóê Bearer ÌÜ†ÌÅ∞ ÌïÑÏöî)
 * @summary ÎπÑÍµêÌëú ÏàòÏ†ï
 */
export type updateComparisonTableResponse200 = {
  data: StandardResponseBoolean;
  status: 200;
};

export type updateComparisonTableResponseComposite =
  updateComparisonTableResponse200;

export type updateComparisonTableResponse =
  updateComparisonTableResponseComposite & {
    headers: Headers;
  };

export const getUpdateComparisonTableUrl = (tableId: number) => {
  return `https://api.ssok.info/api/comparison/${tableId}`;
};

export const updateComparisonTable = async (
  tableId: number,
  updateComparisonTableRequest: UpdateComparisonTableRequest,
  options?: RequestInit,
): Promise<updateComparisonTableResponse> => {
  return http<updateComparisonTableResponse>(
    getUpdateComparisonTableUrl(tableId),
    {
      ...options,
      method: "PUT",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(updateComparisonTableRequest),
    },
  );
};

export const getUpdateComparisonTableMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateComparisonTable>>,
    TError,
    { tableId: number; data: UpdateComparisonTableRequest },
    TContext
  >;
  request?: SecondParameter<typeof http>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateComparisonTable>>,
  TError,
  { tableId: number; data: UpdateComparisonTableRequest },
  TContext
> => {
  const mutationKey = ["updateComparisonTable"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateComparisonTable>>,
    { tableId: number; data: UpdateComparisonTableRequest }
  > = (props) => {
    const { tableId, data } = props ?? {};

    return updateComparisonTable(tableId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateComparisonTableMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateComparisonTable>>
>;
export type UpdateComparisonTableMutationBody = UpdateComparisonTableRequest;
export type UpdateComparisonTableMutationError = unknown;

/**
 * @summary ÎπÑÍµêÌëú ÏàòÏ†ï
 */
export const useUpdateComparisonTable = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateComparisonTable>>,
      TError,
      { tableId: number; data: UpdateComparisonTableRequest },
      TContext
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateComparisonTable>>,
  TError,
  { tableId: number; data: UpdateComparisonTableRequest },
  TContext
> => {
  const mutationOptions = getUpdateComparisonTableMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÎπÑÍµêÌëúÏóê ÏÉàÎ°úÏö¥ ÏàôÏÜåÎ•º Ï∂îÍ∞ÄÌï©ÎãàÎã§. (Authorization Ìó§ÎçîÏóê Bearer ÌÜ†ÌÅ∞ ÌïÑÏöî)
 * @summary ÎπÑÍµêÌëú ÏàôÏÜå Ï∂îÍ∞Ä
 */
export type addAccommodationToComparisonTableResponse200 = {
  data: StandardResponseComparisonTableResponse;
  status: 200;
};

export type addAccommodationToComparisonTableResponseComposite =
  addAccommodationToComparisonTableResponse200;

export type addAccommodationToComparisonTableResponse =
  addAccommodationToComparisonTableResponseComposite & {
    headers: Headers;
  };

export const getAddAccommodationToComparisonTableUrl = (tableId: number) => {
  return `https://api.ssok.info/api/comparison/${tableId}`;
};

export const addAccommodationToComparisonTable = async (
  tableId: number,
  addAccommodationRequest: AddAccommodationRequest,
  options?: RequestInit,
): Promise<addAccommodationToComparisonTableResponse> => {
  return http<addAccommodationToComparisonTableResponse>(
    getAddAccommodationToComparisonTableUrl(tableId),
    {
      ...options,
      method: "PATCH",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(addAccommodationRequest),
    },
  );
};

export const getAddAccommodationToComparisonTableMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addAccommodationToComparisonTable>>,
    TError,
    { tableId: number; data: AddAccommodationRequest },
    TContext
  >;
  request?: SecondParameter<typeof http>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addAccommodationToComparisonTable>>,
  TError,
  { tableId: number; data: AddAccommodationRequest },
  TContext
> => {
  const mutationKey = ["addAccommodationToComparisonTable"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addAccommodationToComparisonTable>>,
    { tableId: number; data: AddAccommodationRequest }
  > = (props) => {
    const { tableId, data } = props ?? {};

    return addAccommodationToComparisonTable(tableId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddAccommodationToComparisonTableMutationResult = NonNullable<
  Awaited<ReturnType<typeof addAccommodationToComparisonTable>>
>;
export type AddAccommodationToComparisonTableMutationBody =
  AddAccommodationRequest;
export type AddAccommodationToComparisonTableMutationError = unknown;

/**
 * @summary ÎπÑÍµêÌëú ÏàôÏÜå Ï∂îÍ∞Ä
 */
export const useAddAccommodationToComparisonTable = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addAccommodationToComparisonTable>>,
      TError,
      { tableId: number; data: AddAccommodationRequest },
      TContext
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof addAccommodationToComparisonTable>>,
  TError,
  { tableId: number; data: AddAccommodationRequest },
  TContext
> => {
  const mutationOptions =
    getAddAccommodationToComparisonTableMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÏÉàÎ°úÏö¥ Ïó¨Ìñâ Î≥¥ÎìúÎ•º ÏÉùÏÑ±Ìï©ÎãàÎã§. JWT Ïù∏Ï¶ùÏùÑ ÌÜµÌï¥ ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Î•º Ï∂îÏ∂úÌïòÍ≥†, ÏÉùÏÑ±ÏûêÎäî ÏûêÎèôÏúºÎ°ú OWNER Ïó≠Ìï†Î°ú Îì±Î°ùÎêòÎ©∞ Í≥†Ïú†Ìïú Ï¥àÎåÄ ÎßÅÌÅ¨Í∞Ä ÏÉùÏÑ±Îê©ÎãàÎã§.
 * @summary Ïó¨Ìñâ Î≥¥Îìú ÏÉùÏÑ±
 */
export type createTripBoardResponse200 = {
  data: StandardResponseTripBoardCreateResponse;
  status: 200;
};

export type createTripBoardResponseComposite = createTripBoardResponse200;

export type createTripBoardResponse = createTripBoardResponseComposite & {
  headers: Headers;
};

export const getCreateTripBoardUrl = () => {
  return `https://api.ssok.info/api/trip-boards/register`;
};

export const createTripBoard = async (
  tripBoardCreateRequest: TripBoardCreateRequest,
  options?: RequestInit,
): Promise<createTripBoardResponse> => {
  return http<createTripBoardResponse>(getCreateTripBoardUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(tripBoardCreateRequest),
  });
};

export const getCreateTripBoardMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTripBoard>>,
    TError,
    { data: TripBoardCreateRequest },
    TContext
  >;
  request?: SecondParameter<typeof http>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createTripBoard>>,
  TError,
  { data: TripBoardCreateRequest },
  TContext
> => {
  const mutationKey = ["createTripBoard"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTripBoard>>,
    { data: TripBoardCreateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createTripBoard(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateTripBoardMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTripBoard>>
>;
export type CreateTripBoardMutationBody = TripBoardCreateRequest;
export type CreateTripBoardMutationError = unknown;

/**
 * @summary Ïó¨Ìñâ Î≥¥Îìú ÏÉùÏÑ±
 */
export const useCreateTripBoard = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createTripBoard>>,
      TError,
      { data: TripBoardCreateRequest },
      TContext
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createTripBoard>>,
  TError,
  { data: TripBoardCreateRequest },
  TContext
> => {
  const mutationOptions = getCreateTripBoardMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌòÑÏû¨ Î°úÍ∑∏Ïù∏Îêú ÏÇ¨Ïö©ÏûêÏùò ÏÑ∏ÏÖòÏùÑ Ï¢ÖÎ£åÌï©ÎãàÎã§. Ìó§ÎçîÏóê ÏûàÎäî access-token ÌÜ†ÌÅ∞ÏùÑ Î∏îÎûôÎ¶¨Ïä§Ìä∏Ïóê Ï∂îÍ∞ÄÌï©ÎãàÎã§. RedisÏóêÏÑú Refresh TokenÏùÑ ÏÇ≠Ï†úÌïòÍ≥† Î∏åÎùºÏö∞Ï†ÄÏùò REFRESH_TOKEN Ïø†ÌÇ§Î•º Î¨¥Ìö®ÌôîÌï©ÎãàÎã§. Î°úÍ∑∏ÏïÑÏõÉ ÌõÑÏóêÎäî ÏÉàÎ°úÏö¥ Ïù∏Ï¶ùÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.
 * @summary ÏÇ¨Ïö©Ïûê Î°úÍ∑∏ÏïÑÏõÉ
 */
export type logoutResponse200 = {
  data: StandardResponseLogoutResponse;
  status: 200;
};

export type logoutResponseComposite = logoutResponse200;

export type logoutResponse = logoutResponseComposite & {
  headers: Headers;
};

export const getLogoutUrl = () => {
  return `https://api.ssok.info/api/oauth/logout`;
};

export const logout = async (
  options?: RequestInit,
): Promise<logoutResponse> => {
  return http<logoutResponse>(getLogoutUrl(), {
    ...options,
    method: "POST",
  });
};

export const getLogoutMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof logout>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof http>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof logout>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["logout"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof logout>>,
    void
  > = () => {
    return logout(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LogoutMutationResult = NonNullable<
  Awaited<ReturnType<typeof logout>>
>;

export type LogoutMutationError = unknown;

/**
 * @summary ÏÇ¨Ïö©Ïûê Î°úÍ∑∏ÏïÑÏõÉ
 */
export const useLogout = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof logout>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof logout>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getLogoutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Ïπ¥Ïπ¥Ïò§ÏóêÏÑú Î∞úÍ∏âÎ∞õÏùÄ Ïù∏Í∞Ä ÏΩîÎìúÎ•º ÌÜµÌï¥ Ïï°ÏÑ∏Ïä§ ÌÜ†ÌÅ∞ÏùÑ ÌöçÎìùÌïòÍ≥†, ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌïòÏó¨ JWT ÌÜ†ÌÅ∞ÏùÑ Ìó§ÎçîÎ°ú ÏÑ§Ï†ïÌï©ÎãàÎã§. JWT ÌÜ†ÌÅ∞ÏùÄ ÏùëÎãµ Ìó§ÎçîÎ°ú Ï†ÑÎã¨ÎêòÎ©∞, ÏùëÎãµ Î∞îÎîîÏóêÎäî ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Îßå Ìè¨Ìï®Îê©ÎãàÎã§. Ïù∏Í∞Ä ÏΩîÎìúÏôÄ baseUrlÏùÄ Query ParameterÎ°ú Ï†ÑÎã¨Ìï¥Ïïº Ìï©ÎãàÎã§. Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ ÌõÑ ÏùëÎãµ Ìó§Îçî access-token, Ïø†ÌÇ§ REFRESH_TOKEN Î°ú Í∞ÅÍ∞Å Ïï°ÏÑ∏Ïä§ ÌÜ†ÌÅ∞, Î¶¨ÌîÑÎ†àÏãú ÌÜ†ÌÅ∞Ïù¥ Ï†ÑÎã¨Îê©ÎãàÎã§.
 * @summary Ïπ¥Ïπ¥Ïò§ OAuth ÌÜ†ÌÅ∞ ÍµêÌôò
 */
export type exchangeKakaoTokenResponse200 = {
  data: StandardResponseOauthLoginResponse;
  status: 200;
};

export type exchangeKakaoTokenResponseComposite = exchangeKakaoTokenResponse200;

export type exchangeKakaoTokenResponse = exchangeKakaoTokenResponseComposite & {
  headers: Headers;
};

export const getExchangeKakaoTokenUrl = (params: ExchangeKakaoTokenParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://api.ssok.info/api/oauth/kakao/token?${stringifiedParams}`
    : `https://api.ssok.info/api/oauth/kakao/token`;
};

export const exchangeKakaoToken = async (
  params: ExchangeKakaoTokenParams,
  options?: RequestInit,
): Promise<exchangeKakaoTokenResponse> => {
  return http<exchangeKakaoTokenResponse>(getExchangeKakaoTokenUrl(params), {
    ...options,
    method: "POST",
  });
};

export const getExchangeKakaoTokenMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof exchangeKakaoToken>>,
    TError,
    { params: ExchangeKakaoTokenParams },
    TContext
  >;
  request?: SecondParameter<typeof http>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof exchangeKakaoToken>>,
  TError,
  { params: ExchangeKakaoTokenParams },
  TContext
> => {
  const mutationKey = ["exchangeKakaoToken"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof exchangeKakaoToken>>,
    { params: ExchangeKakaoTokenParams }
  > = (props) => {
    const { params } = props ?? {};

    return exchangeKakaoToken(params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ExchangeKakaoTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof exchangeKakaoToken>>
>;

export type ExchangeKakaoTokenMutationError = unknown;

/**
 * @summary Ïπ¥Ïπ¥Ïò§ OAuth ÌÜ†ÌÅ∞ ÍµêÌôò
 */
export const useExchangeKakaoToken = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof exchangeKakaoToken>>,
      TError,
      { params: ExchangeKakaoTokenParams },
      TContext
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof exchangeKakaoToken>>,
  TError,
  { params: ExchangeKakaoTokenParams },
  TContext
> => {
  const mutationOptions = getExchangeKakaoTokenMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÎπÑÍµêÌëú Ïù¥Î¶Ñ, ÏàôÏÜå ID Î¶¨Ïä§Ìä∏, ÎπÑÍµê Í∏∞Ï§Ä Ìï≠Î™©ÏùÑ Î∞õÏïÑÏÑú ÎπÑÍµêÌëú Î©îÌÉÄ Îç∞Ïù¥ÌÑ∞Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§. (Authorization Ìó§ÎçîÏóê Bearer ÌÜ†ÌÅ∞ ÌïÑÏöî)
 * @summary ÎπÑÍµêÌëú ÏÉùÏÑ±
 */
export type createComparisonTableResponse200 = {
  data: StandardResponseCreateComparisonTableResponse;
  status: 200;
};

export type createComparisonTableResponseComposite =
  createComparisonTableResponse200;

export type createComparisonTableResponse =
  createComparisonTableResponseComposite & {
    headers: Headers;
  };

export const getCreateComparisonTableUrl = () => {
  return `https://api.ssok.info/api/comparison/new`;
};

export const createComparisonTable = async (
  createComparisonTableRequest: CreateComparisonTableRequest,
  options?: RequestInit,
): Promise<createComparisonTableResponse> => {
  return http<createComparisonTableResponse>(getCreateComparisonTableUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(createComparisonTableRequest),
  });
};

export const getCreateComparisonTableMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createComparisonTable>>,
    TError,
    { data: CreateComparisonTableRequest },
    TContext
  >;
  request?: SecondParameter<typeof http>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createComparisonTable>>,
  TError,
  { data: CreateComparisonTableRequest },
  TContext
> => {
  const mutationKey = ["createComparisonTable"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createComparisonTable>>,
    { data: CreateComparisonTableRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createComparisonTable(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateComparisonTableMutationResult = NonNullable<
  Awaited<ReturnType<typeof createComparisonTable>>
>;
export type CreateComparisonTableMutationBody = CreateComparisonTableRequest;
export type CreateComparisonTableMutationError = unknown;

/**
 * @summary ÎπÑÍµêÌëú ÏÉùÏÑ±
 */
export const useCreateComparisonTable = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createComparisonTable>>,
      TError,
      { data: CreateComparisonTableRequest },
      TContext
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createComparisonTable>>,
  TError,
  { data: CreateComparisonTableRequest },
  TContext
> => {
  const mutationOptions = getCreateComparisonTableMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÎßÅÌÅ¨Î•º Ï≤®Î∂ÄÌïòÏó¨ ÏàôÏÜå Ïπ¥ÎìúÎ•º Îì±Î°ùÌï©ÎãàÎã§.
 * @summary ÏàôÏÜå Ïπ¥Îìú Îì±Î°ù
 */
export type registerAccommodationCardResponse200 = {
  data: StandardResponseAccommodationRegisterResponse;
  status: 200;
};

export type registerAccommodationCardResponseComposite =
  registerAccommodationCardResponse200;

export type registerAccommodationCardResponse =
  registerAccommodationCardResponseComposite & {
    headers: Headers;
  };

export const getRegisterAccommodationCardUrl = () => {
  return `https://api.ssok.info/api/accommodations/register`;
};

export const registerAccommodationCard = async (
  accommodationRegisterRequest: AccommodationRegisterRequest,
  options?: RequestInit,
): Promise<registerAccommodationCardResponse> => {
  return http<registerAccommodationCardResponse>(
    getRegisterAccommodationCardUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(accommodationRegisterRequest),
    },
  );
};

export const getRegisterAccommodationCardMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof registerAccommodationCard>>,
    TError,
    { data: AccommodationRegisterRequest },
    TContext
  >;
  request?: SecondParameter<typeof http>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof registerAccommodationCard>>,
  TError,
  { data: AccommodationRegisterRequest },
  TContext
> => {
  const mutationKey = ["registerAccommodationCard"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof registerAccommodationCard>>,
    { data: AccommodationRegisterRequest }
  > = (props) => {
    const { data } = props ?? {};

    return registerAccommodationCard(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RegisterAccommodationCardMutationResult = NonNullable<
  Awaited<ReturnType<typeof registerAccommodationCard>>
>;
export type RegisterAccommodationCardMutationBody =
  AccommodationRegisterRequest;
export type RegisterAccommodationCardMutationError = unknown;

/**
 * @summary ÏàôÏÜå Ïπ¥Îìú Îì±Î°ù
 */
export const useRegisterAccommodationCard = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof registerAccommodationCard>>,
      TError,
      { data: AccommodationRegisterRequest },
      TContext
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof registerAccommodationCard>>,
  TError,
  { data: AccommodationRegisterRequest },
  TContext
> => {
  const mutationOptions = getRegisterAccommodationCardMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÏÇ¨Ïö©ÏûêÍ∞Ä Ï∞∏Ïó¨Ìïú Ïó¨Ìñâ Î≥¥Îìú Î™©Î°ùÏùÑ ÌéòÏù¥ÏßïÏúºÎ°ú Ï°∞ÌöåÌï©ÎãàÎã§. JWT Ïù∏Ï¶ùÏùÑ ÌÜµÌï¥ ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Î•º Ï∂îÏ∂úÌïòÍ≥†, ÏµúÏã†ÏàúÏúºÎ°ú Ï†ïÎ†¨Îêú Í≤∞Í≥ºÎ•º Î∞òÌôòÌï©ÎãàÎã§.
 * @summary Ïó¨Ìñâ Î≥¥Îìú Î™©Î°ù Ï°∞Ìöå
 */
export type getTripBoardsResponse200 = {
  data: StandardResponseTripBoardPageResponse;
  status: 200;
};

export type getTripBoardsResponseComposite = getTripBoardsResponse200;

export type getTripBoardsResponse = getTripBoardsResponseComposite & {
  headers: Headers;
};

export const getGetTripBoardsUrl = (params: GetTripBoardsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://api.ssok.info/api/trip-boards/search?${stringifiedParams}`
    : `https://api.ssok.info/api/trip-boards/search`;
};

export const getTripBoards = async (
  params: GetTripBoardsParams,
  options?: RequestInit,
): Promise<getTripBoardsResponse> => {
  return http<getTripBoardsResponse>(getGetTripBoardsUrl(params), {
    ...options,
    method: "GET",
  });
};

export const getGetTripBoardsQueryKey = (params?: GetTripBoardsParams) => {
  return [
    `https://api.ssok.info/api/trip-boards/search`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetTripBoardsQueryOptions = <
  TData = Awaited<ReturnType<typeof getTripBoards>>,
  TError = unknown,
>(
  params: GetTripBoardsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTripBoards>>, TError, TData>
    >;
    request?: SecondParameter<typeof http>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTripBoardsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTripBoards>>> = ({
    signal,
  }) => getTripBoards(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTripBoards>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetTripBoardsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTripBoards>>
>;
export type GetTripBoardsQueryError = unknown;

export function useGetTripBoards<
  TData = Awaited<ReturnType<typeof getTripBoards>>,
  TError = unknown,
>(
  params: GetTripBoardsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTripBoards>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTripBoards>>,
          TError,
          Awaited<ReturnType<typeof getTripBoards>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetTripBoards<
  TData = Awaited<ReturnType<typeof getTripBoards>>,
  TError = unknown,
>(
  params: GetTripBoardsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTripBoards>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTripBoards>>,
          TError,
          Awaited<ReturnType<typeof getTripBoards>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetTripBoards<
  TData = Awaited<ReturnType<typeof getTripBoards>>,
  TError = unknown,
>(
  params: GetTripBoardsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTripBoards>>, TError, TData>
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Ïó¨Ìñâ Î≥¥Îìú Î™©Î°ù Ï°∞Ìöå
 */

export function useGetTripBoards<
  TData = Awaited<ReturnType<typeof getTripBoards>>,
  TError = unknown,
>(
  params: GetTripBoardsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTripBoards>>, TError, TData>
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetTripBoardsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Ïó¨Ìñâ Î≥¥Îìú Î™©Î°ù Ï°∞Ìöå
 */
export const prefetchGetTripBoardsQuery = async <
  TData = Awaited<ReturnType<typeof getTripBoards>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  params: GetTripBoardsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTripBoards>>, TError, TData>
    >;
    request?: SecondParameter<typeof http>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetTripBoardsQueryOptions(params, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getGetTripBoardsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getTripBoards>>,
  TError = unknown,
>(
  params: GetTripBoardsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTripBoards>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTripBoardsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTripBoards>>> = ({
    signal,
  }) => getTripBoards(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getTripBoards>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetTripBoardsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTripBoards>>
>;
export type GetTripBoardsSuspenseQueryError = unknown;

export function useGetTripBoardsSuspense<
  TData = Awaited<ReturnType<typeof getTripBoards>>,
  TError = unknown,
>(
  params: GetTripBoardsParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTripBoards>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetTripBoardsSuspense<
  TData = Awaited<ReturnType<typeof getTripBoards>>,
  TError = unknown,
>(
  params: GetTripBoardsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTripBoards>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetTripBoardsSuspense<
  TData = Awaited<ReturnType<typeof getTripBoards>>,
  TError = unknown,
>(
  params: GetTripBoardsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTripBoards>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
/**
 * @summary Ïó¨Ìñâ Î≥¥Îìú Î™©Î°ù Ï°∞Ìöå
 */

export function useGetTripBoardsSuspense<
  TData = Awaited<ReturnType<typeof getTripBoards>>,
  TError = unknown,
>(
  params: GetTripBoardsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTripBoards>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
} {
  const queryOptions = getGetTripBoardsSuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Ïπ¥Ïπ¥Ïò§ OAuth Ïù∏Í∞Ä ÌéòÏù¥ÏßÄ URLÏùÑ Î∞òÌôòÌï©ÎãàÎã§. ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Ïùò baseUrlÏùÑ Í∏∞Î∞òÏúºÎ°ú ÎèôÏ†ÅÏúºÎ°ú redirect_uriÎ•º ÏÉùÏÑ±Ìï©ÎãàÎã§. ÌîÑÎ°†Ìä∏ÏóîÎìúÏóêÏÑú Ïù¥ URLÎ°ú Î¶¨Îã§Ïù¥Î†âÌä∏ÌïòÏó¨ ÏÇ¨Ïö©Ïûê Ïù∏Ï¶ùÏùÑ ÏßÑÌñâÌï©ÎãàÎã§.
 * @summary Ïπ¥Ïπ¥Ïò§ OAuth Ïù∏Í∞Ä URL Ï°∞Ìöå
 */
export type getKakaoAuthorizeUrlResponse200 = {
  data: StandardResponseAuthorizeUrlResponse;
  status: 200;
};

export type getKakaoAuthorizeUrlResponseComposite =
  getKakaoAuthorizeUrlResponse200;

export type getKakaoAuthorizeUrlResponse =
  getKakaoAuthorizeUrlResponseComposite & {
    headers: Headers;
  };

export const getGetKakaoAuthorizeUrlUrl = (
  params: GetKakaoAuthorizeUrlParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://api.ssok.info/api/oauth/kakao/authorize?${stringifiedParams}`
    : `https://api.ssok.info/api/oauth/kakao/authorize`;
};

export const getKakaoAuthorizeUrl = async (
  params: GetKakaoAuthorizeUrlParams,
  options?: RequestInit,
): Promise<getKakaoAuthorizeUrlResponse> => {
  return http<getKakaoAuthorizeUrlResponse>(
    getGetKakaoAuthorizeUrlUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetKakaoAuthorizeUrlQueryKey = (
  params?: GetKakaoAuthorizeUrlParams,
) => {
  return [
    `https://api.ssok.info/api/oauth/kakao/authorize`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetKakaoAuthorizeUrlQueryOptions = <
  TData = Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
  TError = unknown,
>(
  params: GetKakaoAuthorizeUrlParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetKakaoAuthorizeUrlQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>
  > = ({ signal }) =>
    getKakaoAuthorizeUrl(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetKakaoAuthorizeUrlQueryResult = NonNullable<
  Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>
>;
export type GetKakaoAuthorizeUrlQueryError = unknown;

export function useGetKakaoAuthorizeUrl<
  TData = Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
  TError = unknown,
>(
  params: GetKakaoAuthorizeUrlParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
          TError,
          Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetKakaoAuthorizeUrl<
  TData = Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
  TError = unknown,
>(
  params: GetKakaoAuthorizeUrlParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
          TError,
          Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetKakaoAuthorizeUrl<
  TData = Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
  TError = unknown,
>(
  params: GetKakaoAuthorizeUrlParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Ïπ¥Ïπ¥Ïò§ OAuth Ïù∏Í∞Ä URL Ï°∞Ìöå
 */

export function useGetKakaoAuthorizeUrl<
  TData = Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
  TError = unknown,
>(
  params: GetKakaoAuthorizeUrlParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetKakaoAuthorizeUrlQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Ïπ¥Ïπ¥Ïò§ OAuth Ïù∏Í∞Ä URL Ï°∞Ìöå
 */
export const prefetchGetKakaoAuthorizeUrlQuery = async <
  TData = Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  params: GetKakaoAuthorizeUrlParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetKakaoAuthorizeUrlQueryOptions(params, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getGetKakaoAuthorizeUrlSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
  TError = unknown,
>(
  params: GetKakaoAuthorizeUrlParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetKakaoAuthorizeUrlQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>
  > = ({ signal }) =>
    getKakaoAuthorizeUrl(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetKakaoAuthorizeUrlSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>
>;
export type GetKakaoAuthorizeUrlSuspenseQueryError = unknown;

export function useGetKakaoAuthorizeUrlSuspense<
  TData = Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
  TError = unknown,
>(
  params: GetKakaoAuthorizeUrlParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetKakaoAuthorizeUrlSuspense<
  TData = Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
  TError = unknown,
>(
  params: GetKakaoAuthorizeUrlParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetKakaoAuthorizeUrlSuspense<
  TData = Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
  TError = unknown,
>(
  params: GetKakaoAuthorizeUrlParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
/**
 * @summary Ïπ¥Ïπ¥Ïò§ OAuth Ïù∏Í∞Ä URL Ï°∞Ìöå
 */

export function useGetKakaoAuthorizeUrlSuspense<
  TData = Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
  TError = unknown,
>(
  params: GetKakaoAuthorizeUrlParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getKakaoAuthorizeUrl>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
} {
  const queryOptions = getGetKakaoAuthorizeUrlSuspenseQueryOptions(
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÎπÑÍµê Í∏∞Ï§Ä Ìï≠Î™© Enum Î¶¨Ïä§Ìä∏Î•º Î∞òÌôòÌï©ÎãàÎã§.
 * @summary ÎπÑÍµêÌëú Í∏∞Ï§Ä Ìï≠Î™© Enum Î¶¨Ïä§Ìä∏
 */
export type getComparisonFactorListResponse200 = {
  data: StandardResponseComparisonFactorList;
  status: 200;
};

export type getComparisonFactorListResponseComposite =
  getComparisonFactorListResponse200;

export type getComparisonFactorListResponse =
  getComparisonFactorListResponseComposite & {
    headers: Headers;
  };

export const getGetComparisonFactorListUrl = () => {
  return `https://api.ssok.info/api/comparison/factors`;
};

export const getComparisonFactorList = async (
  options?: RequestInit,
): Promise<getComparisonFactorListResponse> => {
  return http<getComparisonFactorListResponse>(
    getGetComparisonFactorListUrl(),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetComparisonFactorListQueryKey = () => {
  return [`https://api.ssok.info/api/comparison/factors`] as const;
};

export const getGetComparisonFactorListQueryOptions = <
  TData = Awaited<ReturnType<typeof getComparisonFactorList>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getComparisonFactorList>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof http>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetComparisonFactorListQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getComparisonFactorList>>
  > = ({ signal }) => getComparisonFactorList({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getComparisonFactorList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetComparisonFactorListQueryResult = NonNullable<
  Awaited<ReturnType<typeof getComparisonFactorList>>
>;
export type GetComparisonFactorListQueryError = unknown;

export function useGetComparisonFactorList<
  TData = Awaited<ReturnType<typeof getComparisonFactorList>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getComparisonFactorList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getComparisonFactorList>>,
          TError,
          Awaited<ReturnType<typeof getComparisonFactorList>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetComparisonFactorList<
  TData = Awaited<ReturnType<typeof getComparisonFactorList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getComparisonFactorList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getComparisonFactorList>>,
          TError,
          Awaited<ReturnType<typeof getComparisonFactorList>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetComparisonFactorList<
  TData = Awaited<ReturnType<typeof getComparisonFactorList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getComparisonFactorList>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÎπÑÍµêÌëú Í∏∞Ï§Ä Ìï≠Î™© Enum Î¶¨Ïä§Ìä∏
 */

export function useGetComparisonFactorList<
  TData = Awaited<ReturnType<typeof getComparisonFactorList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getComparisonFactorList>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetComparisonFactorListQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ÎπÑÍµêÌëú Í∏∞Ï§Ä Ìï≠Î™© Enum Î¶¨Ïä§Ìä∏
 */
export const prefetchGetComparisonFactorListQuery = async <
  TData = Awaited<ReturnType<typeof getComparisonFactorList>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getComparisonFactorList>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetComparisonFactorListQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getGetComparisonFactorListSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getComparisonFactorList>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getComparisonFactorList>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof http>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetComparisonFactorListQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getComparisonFactorList>>
  > = ({ signal }) => getComparisonFactorList({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getComparisonFactorList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetComparisonFactorListSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getComparisonFactorList>>
>;
export type GetComparisonFactorListSuspenseQueryError = unknown;

export function useGetComparisonFactorListSuspense<
  TData = Awaited<ReturnType<typeof getComparisonFactorList>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getComparisonFactorList>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetComparisonFactorListSuspense<
  TData = Awaited<ReturnType<typeof getComparisonFactorList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getComparisonFactorList>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetComparisonFactorListSuspense<
  TData = Awaited<ReturnType<typeof getComparisonFactorList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getComparisonFactorList>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
/**
 * @summary ÎπÑÍµêÌëú Í∏∞Ï§Ä Ìï≠Î™© Enum Î¶¨Ïä§Ìä∏
 */

export function useGetComparisonFactorListSuspense<
  TData = Awaited<ReturnType<typeof getComparisonFactorList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getComparisonFactorList>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
} {
  const queryOptions = getGetComparisonFactorListSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Ìé∏Ïùò ÏÑúÎπÑÏä§ Ìï≠Î™© Enum Î¶¨Ïä§Ìä∏Î•º Î∞òÌôòÌï©ÎãàÎã§.
 * @summary Ìé∏Ïùò ÏÑúÎπÑÏä§ Enum Î¶¨Ïä§Ìä∏
 */
export type getAmenityFactorListResponse200 = {
  data: StandardResponseAmenityFactorList;
  status: 200;
};

export type getAmenityFactorListResponseComposite =
  getAmenityFactorListResponse200;

export type getAmenityFactorListResponse =
  getAmenityFactorListResponseComposite & {
    headers: Headers;
  };

export const getGetAmenityFactorListUrl = () => {
  return `https://api.ssok.info/api/comparison/amenity`;
};

export const getAmenityFactorList = async (
  options?: RequestInit,
): Promise<getAmenityFactorListResponse> => {
  return http<getAmenityFactorListResponse>(getGetAmenityFactorListUrl(), {
    ...options,
    method: "GET",
  });
};

export const getGetAmenityFactorListQueryKey = () => {
  return [`https://api.ssok.info/api/comparison/amenity`] as const;
};

export const getGetAmenityFactorListQueryOptions = <
  TData = Awaited<ReturnType<typeof getAmenityFactorList>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAmenityFactorList>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof http>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAmenityFactorListQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAmenityFactorList>>
  > = ({ signal }) => getAmenityFactorList({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAmenityFactorList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetAmenityFactorListQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAmenityFactorList>>
>;
export type GetAmenityFactorListQueryError = unknown;

export function useGetAmenityFactorList<
  TData = Awaited<ReturnType<typeof getAmenityFactorList>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAmenityFactorList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAmenityFactorList>>,
          TError,
          Awaited<ReturnType<typeof getAmenityFactorList>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetAmenityFactorList<
  TData = Awaited<ReturnType<typeof getAmenityFactorList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAmenityFactorList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAmenityFactorList>>,
          TError,
          Awaited<ReturnType<typeof getAmenityFactorList>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetAmenityFactorList<
  TData = Awaited<ReturnType<typeof getAmenityFactorList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAmenityFactorList>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Ìé∏Ïùò ÏÑúÎπÑÏä§ Enum Î¶¨Ïä§Ìä∏
 */

export function useGetAmenityFactorList<
  TData = Awaited<ReturnType<typeof getAmenityFactorList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAmenityFactorList>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetAmenityFactorListQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Ìé∏Ïùò ÏÑúÎπÑÏä§ Enum Î¶¨Ïä§Ìä∏
 */
export const prefetchGetAmenityFactorListQuery = async <
  TData = Awaited<ReturnType<typeof getAmenityFactorList>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAmenityFactorList>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetAmenityFactorListQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getGetAmenityFactorListSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAmenityFactorList>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAmenityFactorList>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof http>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAmenityFactorListQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAmenityFactorList>>
  > = ({ signal }) => getAmenityFactorList({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAmenityFactorList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetAmenityFactorListSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAmenityFactorList>>
>;
export type GetAmenityFactorListSuspenseQueryError = unknown;

export function useGetAmenityFactorListSuspense<
  TData = Awaited<ReturnType<typeof getAmenityFactorList>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAmenityFactorList>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetAmenityFactorListSuspense<
  TData = Awaited<ReturnType<typeof getAmenityFactorList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAmenityFactorList>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetAmenityFactorListSuspense<
  TData = Awaited<ReturnType<typeof getAmenityFactorList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAmenityFactorList>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
/**
 * @summary Ìé∏Ïùò ÏÑúÎπÑÏä§ Enum Î¶¨Ïä§Ìä∏
 */

export function useGetAmenityFactorListSuspense<
  TData = Awaited<ReturnType<typeof getAmenityFactorList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAmenityFactorList>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
} {
  const queryOptions = getGetAmenityFactorListSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌäπÏ†ï ÏàôÏÜå IDÎ°ú ÏàôÏÜå Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏàôÏÜå Îã®Í±¥ Ï°∞Ìöå
 */
export type getAccommodationByIdResponse200 = {
  data: StandardResponseAccommodationResponse;
  status: 200;
};

export type getAccommodationByIdResponseComposite =
  getAccommodationByIdResponse200;

export type getAccommodationByIdResponse =
  getAccommodationByIdResponseComposite & {
    headers: Headers;
  };

export const getGetAccommodationByIdUrl = (accommodationId: number) => {
  return `https://api.ssok.info/api/accommodations/${accommodationId}`;
};

export const getAccommodationById = async (
  accommodationId: number,
  options?: RequestInit,
): Promise<getAccommodationByIdResponse> => {
  return http<getAccommodationByIdResponse>(
    getGetAccommodationByIdUrl(accommodationId),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetAccommodationByIdQueryKey = (accommodationId?: number) => {
  return [
    `https://api.ssok.info/api/accommodations/${accommodationId}`,
  ] as const;
};

export const getGetAccommodationByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccommodationById>>,
  TError = unknown,
>(
  accommodationId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAccommodationByIdQueryKey(accommodationId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAccommodationById>>
  > = ({ signal }) =>
    getAccommodationById(accommodationId, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!accommodationId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAccommodationById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetAccommodationByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccommodationById>>
>;
export type GetAccommodationByIdQueryError = unknown;

export function useGetAccommodationById<
  TData = Awaited<ReturnType<typeof getAccommodationById>>,
  TError = unknown,
>(
  accommodationId: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationById>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccommodationById>>,
          TError,
          Awaited<ReturnType<typeof getAccommodationById>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetAccommodationById<
  TData = Awaited<ReturnType<typeof getAccommodationById>>,
  TError = unknown,
>(
  accommodationId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationById>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccommodationById>>,
          TError,
          Awaited<ReturnType<typeof getAccommodationById>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetAccommodationById<
  TData = Awaited<ReturnType<typeof getAccommodationById>>,
  TError = unknown,
>(
  accommodationId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏàôÏÜå Îã®Í±¥ Ï°∞Ìöå
 */

export function useGetAccommodationById<
  TData = Awaited<ReturnType<typeof getAccommodationById>>,
  TError = unknown,
>(
  accommodationId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetAccommodationByIdQueryOptions(
    accommodationId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ÏàôÏÜå Îã®Í±¥ Ï°∞Ìöå
 */
export const prefetchGetAccommodationByIdQuery = async <
  TData = Awaited<ReturnType<typeof getAccommodationById>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  accommodationId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetAccommodationByIdQueryOptions(
    accommodationId,
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getGetAccommodationByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccommodationById>>,
  TError = unknown,
>(
  accommodationId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAccommodationByIdQueryKey(accommodationId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAccommodationById>>
  > = ({ signal }) =>
    getAccommodationById(accommodationId, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAccommodationById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetAccommodationByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccommodationById>>
>;
export type GetAccommodationByIdSuspenseQueryError = unknown;

export function useGetAccommodationByIdSuspense<
  TData = Awaited<ReturnType<typeof getAccommodationById>>,
  TError = unknown,
>(
  accommodationId: number,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetAccommodationByIdSuspense<
  TData = Awaited<ReturnType<typeof getAccommodationById>>,
  TError = unknown,
>(
  accommodationId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetAccommodationByIdSuspense<
  TData = Awaited<ReturnType<typeof getAccommodationById>>,
  TError = unknown,
>(
  accommodationId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
/**
 * @summary ÏàôÏÜå Îã®Í±¥ Ï°∞Ìöå
 */

export function useGetAccommodationByIdSuspense<
  TData = Awaited<ReturnType<typeof getAccommodationById>>,
  TError = unknown,
>(
  accommodationId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
} {
  const queryOptions = getGetAccommodationByIdSuspenseQueryOptions(
    accommodationId,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏàôÏÜå Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏàôÏÜå Î™©Î°ù Ï°∞Ìöå
 */
export type getAccommodationByBoardIdAndUserIdResponse200 = {
  data: StandardResponseAccommodationPageResponse;
  status: 200;
};

export type getAccommodationByBoardIdAndUserIdResponseComposite =
  getAccommodationByBoardIdAndUserIdResponse200;

export type getAccommodationByBoardIdAndUserIdResponse =
  getAccommodationByBoardIdAndUserIdResponseComposite & {
    headers: Headers;
  };

export const getGetAccommodationByBoardIdAndUserIdUrl = (
  params: GetAccommodationByBoardIdAndUserIdParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://api.ssok.info/api/accommodations/search?${stringifiedParams}`
    : `https://api.ssok.info/api/accommodations/search`;
};

export const getAccommodationByBoardIdAndUserId = async (
  params: GetAccommodationByBoardIdAndUserIdParams,
  options?: RequestInit,
): Promise<getAccommodationByBoardIdAndUserIdResponse> => {
  return http<getAccommodationByBoardIdAndUserIdResponse>(
    getGetAccommodationByBoardIdAndUserIdUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetAccommodationByBoardIdAndUserIdQueryKey = (
  params?: GetAccommodationByBoardIdAndUserIdParams,
) => {
  return [
    `https://api.ssok.info/api/accommodations/search`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetAccommodationByBoardIdAndUserIdInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>
  >,
  TError = unknown,
>(
  params: GetAccommodationByBoardIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetAccommodationByBoardIdAndUserIdQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>
  > = ({ signal, pageParam = 0 }) =>
    getAccommodationByBoardIdAndUserId(
      { ...params, page: typeof pageParam === "number" ? pageParam : 0 },
      { signal, ...requestOptions },
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetAccommodationByBoardIdAndUserIdInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>
>;
export type GetAccommodationByBoardIdAndUserIdInfiniteQueryError = unknown;

export function useGetAccommodationByBoardIdAndUserIdInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>
  >,
  TError = unknown,
>(
  params: GetAccommodationByBoardIdAndUserIdParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
          TError,
          Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetAccommodationByBoardIdAndUserIdInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>
  >,
  TError = unknown,
>(
  params: GetAccommodationByBoardIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
          TError,
          Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetAccommodationByBoardIdAndUserIdInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>
  >,
  TError = unknown,
>(
  params: GetAccommodationByBoardIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
/**
 * @summary ÏàôÏÜå Î™©Î°ù Ï°∞Ìöå
 */

export function useGetAccommodationByBoardIdAndUserIdInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>
  >,
  TError = unknown,
>(
  params: GetAccommodationByBoardIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
} {
  const queryOptions =
    getGetAccommodationByBoardIdAndUserIdInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ÏàôÏÜå Î™©Î°ù Ï°∞Ìöå
 */
export const prefetchGetAccommodationByBoardIdAndUserIdInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  params: GetAccommodationByBoardIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
): Promise<QueryClient> => {
  const queryOptions =
    getGetAccommodationByBoardIdAndUserIdInfiniteQueryOptions(params, options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getGetAccommodationByBoardIdAndUserIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
  TError = unknown,
>(
  params: GetAccommodationByBoardIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetAccommodationByBoardIdAndUserIdQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>
  > = ({ signal }) =>
    getAccommodationByBoardIdAndUserId(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetAccommodationByBoardIdAndUserIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>
>;
export type GetAccommodationByBoardIdAndUserIdQueryError = unknown;

export function useGetAccommodationByBoardIdAndUserId<
  TData = Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
  TError = unknown,
>(
  params: GetAccommodationByBoardIdAndUserIdParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
          TError,
          Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetAccommodationByBoardIdAndUserId<
  TData = Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
  TError = unknown,
>(
  params: GetAccommodationByBoardIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
          TError,
          Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetAccommodationByBoardIdAndUserId<
  TData = Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
  TError = unknown,
>(
  params: GetAccommodationByBoardIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏàôÏÜå Î™©Î°ù Ï°∞Ìöå
 */

export function useGetAccommodationByBoardIdAndUserId<
  TData = Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
  TError = unknown,
>(
  params: GetAccommodationByBoardIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetAccommodationByBoardIdAndUserIdQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ÏàôÏÜå Î™©Î°ù Ï°∞Ìöå
 */
export const prefetchGetAccommodationByBoardIdAndUserIdQuery = async <
  TData = Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  params: GetAccommodationByBoardIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetAccommodationByBoardIdAndUserIdQueryOptions(
    params,
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getGetAccommodationByBoardIdAndUserIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
  TError = unknown,
>(
  params: GetAccommodationByBoardIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetAccommodationByBoardIdAndUserIdQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>
  > = ({ signal }) =>
    getAccommodationByBoardIdAndUserId(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetAccommodationByBoardIdAndUserIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>
>;
export type GetAccommodationByBoardIdAndUserIdSuspenseQueryError = unknown;

export function useGetAccommodationByBoardIdAndUserIdSuspense<
  TData = Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
  TError = unknown,
>(
  params: GetAccommodationByBoardIdAndUserIdParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetAccommodationByBoardIdAndUserIdSuspense<
  TData = Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
  TError = unknown,
>(
  params: GetAccommodationByBoardIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetAccommodationByBoardIdAndUserIdSuspense<
  TData = Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
  TError = unknown,
>(
  params: GetAccommodationByBoardIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
/**
 * @summary ÏàôÏÜå Î™©Î°ù Ï°∞Ìöå
 */

export function useGetAccommodationByBoardIdAndUserIdSuspense<
  TData = Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
  TError = unknown,
>(
  params: GetAccommodationByBoardIdAndUserIdParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationByBoardIdAndUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
} {
  const queryOptions =
    getGetAccommodationByBoardIdAndUserIdSuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Ïó¨ÌñâÎ≥¥ÎìúÏóê Ìè¨Ìï®Îêú ÏàôÏÜåÏùò Í∞úÏàòÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Ïó¨ÌñâÎ≥¥Îìú ÏàôÏÜå Í∞úÏàò Ï°∞Ìöå
 */
export type getAccommodationCountByBoardIdResponse200 = {
  data: StandardResponseAccommodationCountResponse;
  status: 200;
};

export type getAccommodationCountByBoardIdResponseComposite =
  getAccommodationCountByBoardIdResponse200;

export type getAccommodationCountByBoardIdResponse =
  getAccommodationCountByBoardIdResponseComposite & {
    headers: Headers;
  };

export const getGetAccommodationCountByBoardIdUrl = (
  params: GetAccommodationCountByBoardIdParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://api.ssok.info/api/accommodations/count?${stringifiedParams}`
    : `https://api.ssok.info/api/accommodations/count`;
};

export const getAccommodationCountByBoardId = async (
  params: GetAccommodationCountByBoardIdParams,
  options?: RequestInit,
): Promise<getAccommodationCountByBoardIdResponse> => {
  return http<getAccommodationCountByBoardIdResponse>(
    getGetAccommodationCountByBoardIdUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetAccommodationCountByBoardIdQueryKey = (
  params?: GetAccommodationCountByBoardIdParams,
) => {
  return [
    `https://api.ssok.info/api/accommodations/count`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetAccommodationCountByBoardIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
  TError = unknown,
>(
  params: GetAccommodationCountByBoardIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAccommodationCountByBoardIdQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAccommodationCountByBoardId>>
  > = ({ signal }) =>
    getAccommodationCountByBoardId(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetAccommodationCountByBoardIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccommodationCountByBoardId>>
>;
export type GetAccommodationCountByBoardIdQueryError = unknown;

export function useGetAccommodationCountByBoardId<
  TData = Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
  TError = unknown,
>(
  params: GetAccommodationCountByBoardIdParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
          TError,
          Awaited<ReturnType<typeof getAccommodationCountByBoardId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetAccommodationCountByBoardId<
  TData = Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
  TError = unknown,
>(
  params: GetAccommodationCountByBoardIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
          TError,
          Awaited<ReturnType<typeof getAccommodationCountByBoardId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetAccommodationCountByBoardId<
  TData = Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
  TError = unknown,
>(
  params: GetAccommodationCountByBoardIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Ïó¨ÌñâÎ≥¥Îìú ÏàôÏÜå Í∞úÏàò Ï°∞Ìöå
 */

export function useGetAccommodationCountByBoardId<
  TData = Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
  TError = unknown,
>(
  params: GetAccommodationCountByBoardIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetAccommodationCountByBoardIdQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Ïó¨ÌñâÎ≥¥Îìú ÏàôÏÜå Í∞úÏàò Ï°∞Ìöå
 */
export const prefetchGetAccommodationCountByBoardIdQuery = async <
  TData = Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  params: GetAccommodationCountByBoardIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetAccommodationCountByBoardIdQueryOptions(
    params,
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getGetAccommodationCountByBoardIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
  TError = unknown,
>(
  params: GetAccommodationCountByBoardIdParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAccommodationCountByBoardIdQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAccommodationCountByBoardId>>
  > = ({ signal }) =>
    getAccommodationCountByBoardId(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetAccommodationCountByBoardIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccommodationCountByBoardId>>
>;
export type GetAccommodationCountByBoardIdSuspenseQueryError = unknown;

export function useGetAccommodationCountByBoardIdSuspense<
  TData = Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
  TError = unknown,
>(
  params: GetAccommodationCountByBoardIdParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetAccommodationCountByBoardIdSuspense<
  TData = Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
  TError = unknown,
>(
  params: GetAccommodationCountByBoardIdParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetAccommodationCountByBoardIdSuspense<
  TData = Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
  TError = unknown,
>(
  params: GetAccommodationCountByBoardIdParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
/**
 * @summary Ïó¨ÌñâÎ≥¥Îìú ÏàôÏÜå Í∞úÏàò Ï°∞Ìöå
 */

export function useGetAccommodationCountByBoardIdSuspense<
  TData = Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
  TError = unknown,
>(
  params: GetAccommodationCountByBoardIdParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAccommodationCountByBoardId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
} {
  const queryOptions = getGetAccommodationCountByBoardIdSuspenseQueryOptions(
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Ïó¨Ìñâ Î≥¥ÎìúÏóêÏÑú ÎÇòÍ∞ëÎãàÎã§. OWNERÏù∏ Í≤ΩÏö∞ Í∞ÄÏû• Î®ºÏ†Ä ÏûÖÏû•Ìïú MEMBERÏóêÍ≤å Í∂åÌïúÏù¥ Ïù¥ÏñëÎêòÎ©∞, ÎßàÏßÄÎßâ Ï∞∏Ïó¨ÏûêÏù∏ Í≤ΩÏö∞ Ïó¨ÌñâÎ≥¥ÎìúÍ∞Ä ÏÇ≠Ï†úÎê©ÎãàÎã§. ÎÇòÍ∞ÄÎäî ÏÇ¨Ïö©ÏûêÎäî ÏûêÏã†Ïù¥ ÏÉùÏÑ±Ìïú Î¶¨ÏÜåÏä§(ÎπÑÍµêÌëú, ÏàôÏÜå)Î•º Ïú†ÏßÄÌïòÍ±∞ÎÇò Ï†úÍ±∞Ìï† Ïàò ÏûàÏäµÎãàÎã§.
 * @summary Ïó¨Ìñâ Î≥¥Îìú ÎÇòÍ∞ÄÍ∏∞
 */
export type leaveTripBoardResponse200 = {
  data: StandardResponseTripBoardLeaveResponse;
  status: 200;
};

export type leaveTripBoardResponseComposite = leaveTripBoardResponse200;

export type leaveTripBoardResponse = leaveTripBoardResponseComposite & {
  headers: Headers;
};

export const getLeaveTripBoardUrl = (boardId: number) => {
  return `https://api.ssok.info/api/trip-boards/leave/${boardId}`;
};

export const leaveTripBoard = async (
  boardId: number,
  tripBoardLeaveRequest: TripBoardLeaveRequest,
  options?: RequestInit,
): Promise<leaveTripBoardResponse> => {
  return http<leaveTripBoardResponse>(getLeaveTripBoardUrl(boardId), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(tripBoardLeaveRequest),
  });
};

export const getLeaveTripBoardMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof leaveTripBoard>>,
    TError,
    { boardId: number; data: TripBoardLeaveRequest },
    TContext
  >;
  request?: SecondParameter<typeof http>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof leaveTripBoard>>,
  TError,
  { boardId: number; data: TripBoardLeaveRequest },
  TContext
> => {
  const mutationKey = ["leaveTripBoard"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof leaveTripBoard>>,
    { boardId: number; data: TripBoardLeaveRequest }
  > = (props) => {
    const { boardId, data } = props ?? {};

    return leaveTripBoard(boardId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LeaveTripBoardMutationResult = NonNullable<
  Awaited<ReturnType<typeof leaveTripBoard>>
>;
export type LeaveTripBoardMutationBody = TripBoardLeaveRequest;
export type LeaveTripBoardMutationError = unknown;

/**
 * @summary Ïó¨Ìñâ Î≥¥Îìú ÎÇòÍ∞ÄÍ∏∞
 */
export const useLeaveTripBoard = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof leaveTripBoard>>,
      TError,
      { boardId: number; data: TripBoardLeaveRequest },
      TContext
    >;
    request?: SecondParameter<typeof http>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof leaveTripBoard>>,
  TError,
  { boardId: number; data: TripBoardLeaveRequest },
  TContext
> => {
  const mutationOptions = getLeaveTripBoardMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
